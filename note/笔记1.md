
###  Spring IOC  AOP 原理，bean 的初始化过程

IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的

反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。

AOP（Aspect Orient Programming），我们一般称为面向方面（切面）编程，作为面向对象的一种补充，用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等。AOP实现的关键在于AOP框架自动创建的AOP代理，AOP代理主要分为静态代理和动态代理，静态代理的代表为AspectJ；而动态代理则以Spring AOP为代表

Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。

Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类

如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的

实例化 初始化  使用 销毁 

###  mysql  的读写分离

读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。

使用读写分离原因： 数据库写入影响了查询的效率

主从复制与读写分离
支持的复制：基于语句的复制  ，  基于行的复制

读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全

实现方式：基于程序代码内部实现，   基于中间代理层实现


###  订单系统出现网络问题，导致重复提交，怎么解决？

网站提示： 
1. 你提交的动作过快，请稍后尝试
2. 你的订单已经超时，请刷新页面后重新提交

第一个：限制某个时间内的最大操作次数只需要有一个计数器就可以，计数器可以用redis实现，设置一个带有有效时间的值作为计数器，如果值不存在则自动创建，超过某一个值就认为操作次数用完即可以实现

第二个：可以使用token机制，token即令牌，学过spring security的相信对这个词不会陌生。我们可以使用类似spring security的机制在页面上生成一个token，当提交订单时，根据该token的有效时间和允许的使用次数来判断订单是否允许提交，从而规避重复提交的问题。当然，有人会问，在高并发的情况下，如果是判断token有效之前有很多同一个用户的提交线程过来（用户正常使用一般不会出现这种情况，一般是压力测试工具导致的），那么还是会重复提交，所以，这里需要用到锁机制，访问同一个用户的token同一时间只能有一个线程，token使用之后失效了就会被清掉，之后的线程就找不到该token，从而认为订单不能提交。



# 记录

### 注解

@JsonSerialize(using = ToStringSerializer.class) ：将Long值返回给前端时转为String（JackJson）

@TableId(value = "id", type = IdType.ASSIGN_ID)：如果不设置 type 值，默认则使用 IdType.ASSIGN_ID 策略（自 3.3.0 起）。该策略会使用雪花算法自动生成主键 ID，主键类型为 Long 或 String（分别对应 MySQL 的表字段为 BIGINT 和 VARCHAR）（SpringBoot - MyBatis-Plus）

@EqualsAndHashCode(callSuper = true)：实现equals, hashCode方法 通过callSuper包含父类的equals 和 hashCode.(lombook)

Maven使用dependencyManagement元索来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元索。只是声明依赖， 并不实现引入,因此子项目需要显示的声明需要用的依赖.如果不在子项目中声明依赖，是不会从父项目中继承下来的;只有在子项目中写了该依赖项,并且没有指定具体版本,才会从父项目中继承该项，并且version和scope都读取自父pom.如果子项目中指定了版本号,那么会使用子项目中指定的jar版本。

Maven使用parent 项目的pom文件来管理项目中的公告依赖。




### spring 的事件机制

事件驱动模型通常也被理解成观察者或者发布/订阅模型

Spring的事件驱动模型由三部分组成：

 - 事件：ApplicationEvent，继承自JDK的EventObject，所有事件将继承它，并通过source得到事件源
 - 事件发布者：ApplicationEventPublisher及ApplicationEventMulticaster接口，使用这个接口，我们的Service就拥有了发布事件的能力
 - 事件订阅者：ApplicationListener，继承自JDK的EventListener，所有监听器将继承它。


Spring 默认对 ApplicationEvent 事件提供了4种实现：ContextStoppedEvent、ContextRefreshedEvent、ContextClosedEvent、ContextStartedEvent

事件基类ApplicationEvent，所有的具体事件都会继承该抽象事件类。ApplicationListener继承自JDK的EventListener，JDK要求所有监听器将继承它。  提供了onApplicationEvent方法，用以处理ApplicationEvent，不过对于具体事件的处理需要进行判断

 Spring也支持直接注解的形式进行事件监听@EventListener(Event.class)。

ApplicationContext接口继承了ApplicationEventPublisher，并在AbstractApplicationContext实现了具体代码，实际执行是委托给ApplicationEventMulticaster。

发布事件时只需要调用ApplicationContext中的publishEvent方法即可进行事件的发布。

 




